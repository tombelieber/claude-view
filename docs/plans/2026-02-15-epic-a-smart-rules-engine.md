---
status: draft
date: 2026-02-15
epic: coaching-automation
---

# Epic A: Smart Rules Engine

> Pattern insights → 1-click apply → `.claude/rules/` → Claude automatically follows the advice

## Problem

The app computes 60+ behavioral patterns with actionable recommendations (e.g., "Keep sessions under 45 minutes"), but users must **manually** change their behavior. There's no mechanism to translate insights into automated behavior change.

## Solution

Add an **"Apply Rule"** button to PatternCard. When clicked, it writes a concise coaching rule as a `.md` file in `~/.claude/rules/`. Claude Code automatically reads these files at session start — the rule takes effect immediately with zero user effort.

## Why `.claude/rules/` instead of modifying CLAUDE.md

Per [Anthropic's official guidance](https://code.claude.com/docs/en/best-practices):

> "Bloated CLAUDE.md files cause Claude to ignore your actual instructions!"

The `.claude/rules/` directory is the **official mechanism** for modular, topic-specific rules:

| Approach | Risk | Reversibility | Auto-loaded |
|----------|------|---------------|-------------|
| Append to CLAUDE.md | **High** — context bloat, corruption risk, hard to audit | Hard — must parse and remove lines | Yes |
| `.claude/rules/*.md` files | **None** — isolated files, no existing files touched | Easy — delete the file | Yes |

Additional benefits:
- Supports `paths:` frontmatter for conditional rules (only apply to certain file types)
- User-level (`~/.claude/rules/`) applies across all projects
- Project-level (`./.claude/rules/`) for project-specific coaching
- Claude Code automatically discovers all `.md` files in this directory recursively

## User Flow

```
1. User opens Insights → Patterns tab (already exists)
2. Sees pattern: "Your 15-45min sessions have 45% lower re-edit rate"
3. Card shows recommendation: "Consider aiming for 15-45min sessions"
4. New [Apply Rule] button visible on cards that have recommendations
5. Click → POST /api/coaching/rules { patternId, recommendation, scope }
6. Backend writes ~/.claude/rules/coaching-S01.md (or ./.claude/rules/ for project scope)
7. Toast: "Rule applied — Claude will follow this in future sessions"
8. Button changes to [Applied ✓] with option to remove
9. If user has 8+ active rules → warning: "You have many coaching rules. Claude works best with fewer, focused rules."
```

## Rule File Format

Each applied rule becomes a file like `~/.claude/rules/coaching-S01.md`:

```markdown
---
# Auto-generated by claude-view coaching engine
# Pattern: S01 — Session Duration Sweet Spot
# Applied: 2026-02-15
# Impact: 72% (high confidence, 127 sessions)
---

Consider aiming for 15-45 minute sessions when possible. Break complex tasks into focused sub-sessions rather than running one long session.
```

Design decisions:
- **Filename convention:** `coaching-{patternId}.md` — predictable, prevents duplicates
- **YAML frontmatter as comments:** Metadata for the app to manage, but doesn't add to Claude's context budget since it's in comments
- **1-2 sentences max:** Concise rule, not a lecture. Follows official guidance: "Be specific: 'Use 2-space indentation' is better than 'Format code properly'"
- **No `paths:` by default:** Coaching rules apply globally. Future: project-scoped rules could use `paths:`

## Budget System

Official docs warn about bloat. We enforce discipline:

| Constraint | Value | Rationale |
|-----------|-------|-----------|
| Max active rules | **8** | ~400 tokens total. Official docs: prune regularly, keep it short |
| Max tokens per rule | **~50 tokens** (1-2 sentences) | Each line should earn its place |
| Soft warning at | **6 rules** | "You have 6 coaching rules. Consider removing less impactful ones." |
| Hard cap at | **8 rules** | Button disabled with tooltip: "Remove a rule first" |

UI shows: `"4/8 coaching slots"` in the Patterns page header.

Why 8: Each rule is ~50 tokens. 8 rules = ~400 tokens. Claude Code's system prompt is ~4000-8000 tokens. 400 tokens is ~5-10% of the system prompt — meaningful but not overwhelming.

## Implementation Plan

### Task 1: Backend — Rule management API (Rust)

**New file:** `crates/server/src/routes/coaching.rs`

**Endpoints:**

```
GET  /api/coaching/rules      → list all active coaching rules
POST /api/coaching/rules      → apply a new rule (write file)
DELETE /api/coaching/rules/:id → remove a rule (delete file)
```

**GET /api/coaching/rules response:**
```json
{
  "rules": [
    {
      "id": "S01",
      "patternId": "S01",
      "title": "Session Duration Sweet Spot",
      "body": "Consider aiming for 15-45 minute sessions when possible.",
      "scope": "user",
      "appliedAt": "2026-02-15T10:30:00Z",
      "filePath": "~/.claude/rules/coaching-S01.md"
    }
  ],
  "count": 1,
  "maxRules": 8
}
```

**POST /api/coaching/rules request:**
```json
{
  "patternId": "S01",
  "recommendation": "Consider aiming for 15-45 minute sessions when possible.",
  "title": "Session Duration Sweet Spot",
  "impactScore": 0.72,
  "sampleSize": 127,
  "scope": "user"
}
```

**Codebase-verified implementation details:**

Imports (matching existing codebase patterns):
```rust
use axum::{
    extract::{Path, State},
    routing::{delete, get, post},
    Json, Router,
};
use serde::{Deserialize, Serialize};
use ts_rs::TS;
use std::sync::Arc;
use crate::{error::ApiResult, state::AppState};
```

**Request struct** (needs `Deserialize` for JSON parsing from POST body):
```rust
#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ApplyRuleRequest {
    pub pattern_id: String,
    pub recommendation: String,
    pub title: String,
    pub impact_score: f64,
    pub sample_size: usize,
    pub scope: String, // "user" | "project"
}
```

**Response structs** (need `Serialize` + `TS` for JSON response + TypeScript generation):
```rust
#[derive(Debug, Serialize, TS)]
#[ts(export, export_to = "../../../src/types/generated/")]
#[serde(rename_all = "camelCase")]
pub struct CoachingRule {
    pub id: String,
    pub pattern_id: String,
    pub title: String,
    pub body: String,
    pub scope: String,
    pub applied_at: String, // ISO 8601
    pub file_path: String,
}

#[derive(Debug, Serialize, TS)]
#[ts(export, export_to = "../../../src/types/generated/")]
#[serde(rename_all = "camelCase")]
pub struct ListRulesResponse {
    pub rules: Vec<CoachingRule>,
    pub count: usize,
    pub max_rules: usize,
}

#[derive(Debug, Serialize, TS)]
#[ts(export, export_to = "../../../src/types/generated/")]
#[serde(rename_all = "camelCase")]
pub struct RemoveRuleResponse {
    pub removed: bool,
    pub id: String,
}
```

Route registration (in `crates/server/src/routes/mod.rs`):
```rust
pub mod coaching;  // add to module declarations

// In api_routes():
.nest("/api", coaching::router())
```

Router function (matching existing pattern):
```rust
pub fn router() -> Router<Arc<AppState>> {
    Router::new()
        .route("/coaching/rules", get(list_rules))
        .route("/coaching/rules", post(apply_rule))
        .route("/coaching/rules/{id}", delete(remove_rule))
}
```

Handler signature (matching existing pattern):
```rust
async fn list_rules(
    State(_state): State<Arc<AppState>>,
) -> ApiResult<Json<ListRulesResponse>> { ... }

async fn apply_rule(
    State(_state): State<Arc<AppState>>,
    Json(req): Json<ApplyRuleRequest>,
) -> ApiResult<Json<CoachingRule>> { ... }

async fn remove_rule(
    State(_state): State<Arc<AppState>>,
    Path(id): Path<String>,
) -> ApiResult<Json<RemoveRuleResponse>> { ... }
```

File I/O: Use sync `std::fs` (acceptable for small config files — codebase already does this in `system.rs` for cache operations).

Rules directory resolution (testable via AppState injection):

Add a `rules_dir` field to `AppState`:
```rust
// In crates/server/src/state.rs — add to AppState struct:
pub rules_dir: PathBuf,

// In AppState::new() — set default:
rules_dir: dirs::home_dir()
    .expect("home dir exists")
    .join(".claude")
    .join("rules"),
```

Handlers read the path from state:
```rust
async fn list_rules(
    State(state): State<Arc<AppState>>,
) -> ApiResult<Json<ListRulesResponse>> {
    let rules_dir = &state.rules_dir;
    // ... use rules_dir for filesystem operations
}
```

Tests override it via a builder or by directly setting the field:
```rust
let mut state = AppState::new(db);
// Override rules_dir to temp dir for test isolation
Arc::get_mut(&mut state).unwrap().rules_dir = temp_dir.path().to_path_buf();
```

**Why not env vars?** `std::env::set_var` requires `unsafe` on Rust 1.93+ and is unsound when tests run in parallel. AppState injection is safe and idiomatic.

**Note:** DELETE is a new HTTP method for this codebase (first DELETE endpoint). Import `delete` from `axum::routing`.

**Implementation steps:**

1. Add `coaching.rs` route module with all 3 handlers
2. Add `pub mod coaching;` to `crates/server/src/routes/mod.rs` (after `pub mod classify;`, alphabetical order — around line 4)
3. Add `.nest("/api", coaching::router())` to `api_routes()` function (after `.nest("/api", classify::router())` to maintain alphabetical order — around line 90)
4. Pattern ID validation: `fn is_valid_pattern_id(id: &str) -> bool` — must match `^[A-Za-z][A-Za-z0-9-]{0,9}$` (letter start, alphanumeric + dash, max 10 chars). Rejects `../`, empty strings, and non-ASCII
5. Ensure `~/.claude/rules/` directory exists (create with `fs::create_dir_all` if missing)

**Error mapping:**
- Budget exceeded (8 rules) → `ApiError::Conflict("Maximum 8 coaching rules...")`
- Invalid pattern ID → `ApiError::BadRequest("Invalid pattern ID")`
- Rule not found on DELETE → `ApiError::BadRequest("Rule not found: {id}")` (no generic `NotFound` variant exists; `BadRequest` is acceptable, or optionally add `NotFound(String)` to `error.rs`)
- Filesystem errors → `ApiError::Internal(msg)` + `tracing::error!`

**Edge cases:**
- `~/.claude/` doesn't exist → `create_dir_all` creates full path (safe, see Security section)
- File already exists for same pattern ID → overwrite (idempotent)
- User deletes file manually outside app → `list_rules()` reflects reality (filesystem is truth)
- Permission denied writing to `~/.claude/` → return `ApiError::Internal` with clear error message + `tracing::error!` log

**`list_rules()` parsing strategy:**

Scan `rules_dir` for files matching `coaching-*.md`. For each file:
1. Read file contents as string
2. Parse comment-based metadata from the `---` comment block at the top:
   - Extract `Pattern:` line → split on `—` to get pattern ID and title
   - Extract `Applied:` line → parse as date string for `applied_at`
   - Extract `Impact:` line → parse percentage for display
3. Everything after the closing `---` is the `body` (the actual rule text)
4. If parsing fails for a file, skip it with a `tracing::warn!` (don't crash the whole listing)

```rust
fn parse_rule_file(path: &Path) -> Option<CoachingRule> {
    let content = std::fs::read_to_string(path).ok()?;
    let filename = path.file_stem()?.to_str()?;
    let id = filename.strip_prefix("coaching-")?;

    // Extract metadata from comment block
    let mut title = String::new();
    let mut applied_at = String::new();
    let mut in_header = false;
    let mut body_lines = Vec::new();

    for line in content.lines() {
        if line.starts_with("---") {
            in_header = !in_header;
            continue;
        }
        if in_header {
            if line.starts_with("# Pattern:") {
                // "# Pattern: S01 — Session Duration Sweet Spot"
                if let Some(rest) = line.split('—').nth(1) {
                    title = rest.trim().to_string();
                }
            } else if line.starts_with("# Applied:") {
                applied_at = line.trim_start_matches("# Applied:").trim().to_string();
            }
        } else if !line.is_empty() {
            body_lines.push(line);
        }
    }

    Some(CoachingRule {
        id: id.to_string(),
        pattern_id: id.to_string(),
        title,
        body: body_lines.join(" "),
        scope: "user".to_string(),
        applied_at,
        file_path: path.display().to_string(),
    })
}
```

### Task 2: Frontend — PatternCard "Apply Rule" button

**Modified file:** `src/components/insights/PatternCard.tsx`

Add to PatternCard (only visible when `pattern.recommendation` is not null):

```tsx
// Below the recommendation text, add:
<ApplyRuleButton
  patternId={pattern.patternId}
  recommendation={pattern.recommendation}
  title={pattern.title}
  impactScore={pattern.impactScore}
  sampleSize={pattern.evidence.sampleSize}
/>
```

**New file:** `src/components/insights/ApplyRuleButton.tsx`

**UI approach:** Codebase uses raw `<button>` with Tailwind classes (no shadcn/ui). Use `@radix-ui/react-popover` (already installed) for any popover/panel. Use `sonner` (already installed + configured in `main.tsx`) for toasts: `import { toast } from 'sonner'`.

States:
- **idle** — "Apply Rule" button (subtle, secondary style via Tailwind)
- **loading** — spinner while POST in flight
- **applied** — "Applied" with checkmark, click to remove
- **error** — brief error toast via `toast.error()`, revert to idle
- **disabled** — budget full (8/8), tooltip via `@radix-ui/react-tooltip` (already installed) explains

**Implementation steps:**

1. Create `ApplyRuleButton.tsx` component
2. Create `src/hooks/use-coaching-rules.ts` — React Query hook for GET/POST/DELETE
3. Modify `PatternCard.tsx` to include button when recommendation exists
4. Add toast notifications for apply/remove actions

### Task 3: Frontend — Rules budget indicator

**Modified file:** `src/components/insights/PatternsTab.tsx`

**Note:** PatternsTab currently has NO header — it renders pattern groups directly. A header wrapper must be added first.

Add a header wrapper with a coaching budget indicator:

```tsx
// Add before the existing <div className="space-y-8 pt-4"> block:
<div className="flex items-center justify-between mb-4">
  <span className="text-sm text-muted-foreground">
    {totalPatterns} patterns
  </span>
  <CoachingBudget />
</div>
```

Where `totalPatterns = groups.high.length + groups.medium.length + groups.observations.length`.

Clicking "4/8 rules active" opens a small panel listing applied rules with remove buttons.

**Implementation steps:**

1. Add header wrapper to PatternsTab (currently missing — must be created)
2. Add `CoachingBudget` component to the new header
3. Show applied count / max (e.g., "4/8 rules active")
4. Expandable panel with list of active rules + remove buttons (use `@radix-ui/react-popover`, already installed)
5. Warning state at 6+, disabled state at 8

### Task 4: Frontend — Active Rules management panel

**New file:** `src/components/insights/CoachingRulesPanel.tsx`

A collapsible panel (or modal) showing all active coaching rules:

```
┌─ Active Coaching Rules (4/8) ────────────────────────┐
│                                                       │
│  S01  Session Duration Sweet Spot            [Remove] │
│       "Consider aiming for 15-45min sessions..."      │
│       Applied Feb 15 · High impact                    │
│                                                       │
│  W03  Planning Before Execution              [Remove] │
│       "Spend time reading relevant code..."           │
│       Applied Feb 14 · High impact                    │
│                                                       │
│  P01  Optimal Prompt Length                  [Remove] │
│       "Try keeping prompts between 20-50 words..."    │
│       Applied Feb 13 · Medium impact                  │
│                                                       │
│  B01  Retry Patterns                         [Remove] │
│       "If you hit 3+ re-edits, try rephrasing..."     │
│       Applied Feb 12 · Medium impact                  │
│                                                       │
│  ℹ️ Claude reads these rules at session start.         │
│  Fewer, focused rules work better than many.          │
└───────────────────────────────────────────────────────┘
```

### Task 5: Tests

**Backend tests (Rust) — follows route-scoped pattern from `classify.rs:818+`:**

Test infrastructure (matching newer codebase convention):
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use axum::{body::Body, http::{Method, Request, StatusCode}, Router};
    use tower::ServiceExt;
    use claude_view_db::Database;
    use crate::state::AppState;
    use tempfile::TempDir;
    use std::sync::Arc;

    async fn test_db() -> Database {
        Database::new_in_memory().await.expect("in-memory DB")
    }

    fn build_app_with_rules_dir(db: Database, rules_dir: PathBuf) -> Router {
        let mut state = AppState::new(db);
        // Override rules_dir for test isolation (avoids polluting ~/.claude/rules/)
        Arc::get_mut(&mut state).unwrap().rules_dir = rules_dir;
        Router::new()
            .nest("/api", router())
            .with_state(state)
    }

    /// Helper to send a request and get (status, body) tuple
    async fn do_request(app: Router, method: Method, uri: &str, body: Option<&str>) -> (StatusCode, String) {
        let mut builder = Request::builder().method(method).uri(uri);
        let body = if let Some(json) = body {
            builder = builder.header("content-type", "application/json");
            Body::from(json.to_string())
        } else {
            Body::empty()
        };
        let response = app.oneshot(builder.body(body).unwrap()).await.unwrap();
        let status = response.status();
        let bytes = axum::body::to_bytes(response.into_body(), usize::MAX).await.unwrap();
        (status, String::from_utf8(bytes.to_vec()).unwrap())
    }
}
```

**Note:** Two test patterns exist in the codebase — `system.rs` uses `crate::create_app(db)` (full app), `classify.rs` uses route-scoped `AppState::new(db)` + `.nest()`. We use the route-scoped pattern here for isolation.

Test cases:
- `test_list_rules_empty` — GET returns empty list when no coaching files exist
- `test_apply_rule_creates_file` — POST creates `.md` file with correct frontmatter + content
- `test_apply_rule_budget_cap` — POST returns 409 Conflict when 8 rules exist
- `test_remove_rule_deletes_file` — DELETE removes file, subsequent GET doesn't include it
- `test_list_rules_reflects_filesystem` — manually created files show up in GET
- `test_apply_rule_idempotent` — POST same pattern ID twice overwrites (no duplicate)
- `test_invalid_pattern_id_rejected` — POST with `../etc/passwd` returns 400 Bad Request
- `test_remove_nonexistent_rule` — DELETE on missing ID returns 400 Bad Request (no generic `NotFound` variant exists; `BadRequest` is used)

**Frontend tests (Vitest — uses `vi.fn()` fetch mocking, NOT MSW):**

Test wrapper pattern (matches codebase convention):
```tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

const mockFetch = vi.fn()
global.fetch = mockFetch

function createWrapper() {
  const queryClient = new QueryClient({
    defaultOptions: { queries: { retry: false } },
  })
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  )
}
```

Test cases:
- `ApplyRuleButton` — render states (idle, applied, disabled, loading)
- `CoachingRulesPanel` — list, remove, budget display
- `use-coaching-rules` hook — API integration with `vi.fn()` fetch mocks

### Task 6: Wiring verification (MANDATORY per CLAUDE.md)

Before declaring done:
1. Routes registered in `mod.rs` and added to Axum router
2. React Query hooks connected to real API endpoints
3. Toast notifications wired to a toast provider
4. End-to-end: click Apply → file appears in `~/.claude/rules/` → click Remove → file gone
5. Budget indicator updates in real-time after apply/remove

## What This Does NOT Include

- Project-scoped rules (`./.claude/rules/`) — deferred to v2
- Smart rule consolidation (merging similar rules) — deferred
- Rule effectiveness tracking (did the rule improve metrics?) — deferred
- Custom rule editing (user writes their own rule text) — deferred
- Integration with classification data — deferred

## Security Considerations

- **Path traversal:** Pattern IDs are validated (alphanumeric + dash only). Never allow user-controlled path segments.
- **File permissions:** Write with user's default permissions (0644). Don't chmod.
- **No arbitrary content:** Rule body comes from our templates, not user input. Prevents injection of malicious instructions.
- **Directory creation:** Use `fs::create_dir_all` for `~/.claude/rules/`. This safely creates parent directories if missing. If Claude Code is not installed (`~/.claude/` doesn't exist), the rules will be created but won't take effect until Claude Code is installed — this is harmless.

## Success Criteria

1. User can apply a coaching rule in 1 click from the Patterns tab
2. Rule file appears in `~/.claude/rules/` and is readable by Claude Code
3. Budget cap prevents over-accumulation
4. Applied state persists across page refreshes (filesystem is truth)
5. Remove action cleanly deletes the file

## Sources

- [Claude Code Best Practices — CLAUDE.md guidance](https://code.claude.com/docs/en/best-practices)
- [Claude Code Memory — .claude/rules/ specification](https://code.claude.com/docs/en/memory)
- [Writing a good CLAUDE.md — HumanLayer](https://www.humanlayer.dev/blog/writing-a-good-claude-md)
- [Claude Skills and CLAUDE.md guide — Gend.co](https://www.gend.co/blog/claude-skills-claude-md-guide)

## Changelog of Fixes Applied (Audit → Final Plan)

### Round 1 (Initial Draft Review)

| # | Issue | Severity | Fix Applied |
|---|-------|----------|-------------|
| 1 | Plan used `serde_json::Json` — codebase uses `axum::Json` | Blocker | Changed all imports to `axum::Json` |
| 2 | Response structs missing `#[derive(Debug, Serialize, TS)]` and `#[ts(export)]` attributes | Blocker | Added full derive macro chain matching codebase convention |
| 3 | Missing `#[serde(rename_all = "camelCase")]` on response types | Warning | Added to all response structs |
| 4 | DELETE is a new HTTP method for this codebase (no existing DELETE handlers) | Warning | Documented as new pattern, added `delete` import |
| 5 | Home dir resolution used generic error — codebase has `DiscoveryError::HomeDirNotFound` | Minor | Updated to use `ApiError::Internal` (simpler, no cross-crate dep needed for filesystem op) |
| 6 | Plan didn't specify route registration location | Warning | Added exact line references: `mod.rs` lines 3-22 for module, line 95 for `.nest()` |
| 7 | Plan didn't specify `Path` extractor for DELETE handler | Blocker | Added `axum::extract::Path` import and handler signature |
| 8 | Test section didn't match codebase patterns | Warning | Added full test infrastructure with `tower::ServiceExt`, `test_db()`, `build_app()` |
| 9 | Missing path traversal validation details | Warning | Added `is_valid_pattern_id()` function spec (alphanumeric + dash, max 10 chars) |
| 10 | File I/O async vs sync unclear | Minor | Documented: sync `std::fs` acceptable for small files (matches `system.rs` pattern) |

### Round 2 (4-Agent Codebase Audit)

| # | Issue | Severity | Fix Applied |
|---|-------|----------|-------------|
| 11 | Security section contradicts implementation: says "never create `~/.claude/`" but `create_dir_all` WILL create it | Blocker | Rewrote security section to accurately describe `create_dir_all` behavior; removed false constraint |
| 12 | No mechanism to override `rules_dir` for tests — tests would pollute user's `~/.claude/rules/` | Blocker | Added `rules_dir` field to AppState with injection for tests |
| 13 | Plan references MSW mocks but MSW is not installed; codebase uses `vi.fn()` fetch mocking | Blocker | Replaced MSW references with actual `vi.fn()` pattern + `QueryClientProvider` wrapper matching codebase convention |
| 14 | PatternsTab has no header — plan assumed one exists for budget indicator | Warning | Documented that header must be added first; provided exact insertion code |
| 15 | No shadcn/ui components — plan assumed Button/Dialog exist | Warning | Documented: use raw `<button>` + Tailwind, `@radix-ui/react-popover` (installed), `sonner` (installed) for toasts |
| 16 | Test infrastructure used `crate::create_app(db)` but newer tests use route-scoped `AppState::new(db)` + `.nest()` | Warning | Rewrote test infrastructure to use route-scoped pattern from `classify.rs:818+` |
| 17 | Route registration line numbers slightly off | Minor | Updated to specify exact insertion points: after `pub mod classify;` and after `.nest("/api", live::router())` |
| 18 | No generic `NotFound` variant for DELETE 404 | Minor | Added error mapping section documenting which `ApiError` variant to use for each HTTP status |

### Round 3 (Adversarial Review — Score: 72 → Fixes Applied)

| # | Issue | Severity | Fix Applied |
|---|-------|----------|-------------|
| 19 | Missing `ApplyRuleRequest` struct definition with `#[derive(Deserialize)]` — handler references it but plan never defines it | Blocker | Added full struct definitions for `ApplyRuleRequest`, `ListRulesResponse`, `RemoveRuleResponse`, and `CoachingRule` with correct derive macros |
| 20 | `std::env::set_var` requires `unsafe` on Rust 1.93+ — test helper would not compile | Blocker | Replaced env var approach with AppState `rules_dir` field injection; `build_app_with_rules_dir()` test helper overrides via `Arc::get_mut` |
| 21 | Duplicate home directory resolution — old inline block AND new `rules_dir()` function both existed | Blocker | Removed old inline block; single source of truth is now `AppState.rules_dir` |
| 22 | Test expects 404 for nonexistent rule but `ApiError::BadRequest` maps to 400 | Warning | Updated test case description to expect 400 Bad Request |
| 23 | `.nest()` insertion after `live::router()` breaks alphabetical consistency with module declarations | Warning | Changed to insert after `classify::router()` (around line 90) |
| 24 | Pattern ID validation too broad — `alphanumeric + dash` allows unexpected inputs | Minor | Tightened to regex `^[A-Za-z][A-Za-z0-9-]{0,9}$` |
| 25 | No spec for how `list_rules()` parses metadata from rule files | Minor | Added `parse_rule_file()` implementation with comment-block parsing logic |
